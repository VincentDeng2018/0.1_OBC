###############################################################################
#
# IAR ANSI C/C++ Compiler V7.80.4.12462/W32 for ARM       19/Nov/2018  00:47:29
# Copyright 1999-2017 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c
#    Command line =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c
#        -D USE_STDPERIPH_DRIVER -D STM32F10X_CL -D USE_STM3210C_EVAL -D
#        USE_USB_OTG_FS -lcN
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\List
#        -o
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\Obj
#        --debug --endian=little --cpu=Cortex-M3 -e --fpu=None --dlib_config
#        "E:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.5\arm\INC\c\DLib_Config_Full.h" -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32F10x_StdPeriph_Driver\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32_USB_OTG_Driver\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Utilities\STM32_EVAL\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Utilities\STM32_EVAL\Common\
#        -I
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\..\..\..\..\Utilities\STM32_EVAL\STM3210C_EVAL\
#        -Ohz --use_c++_inline -I "E:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.5\arm\CMSIS\Include\"
#    Locale       =  Chinese (Simplified)_China.936
#    List file    =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\List\stm32f10x_gpio.lst
#    Object file  =  
#        E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Project\USB_Device_Examples\VCP\EWARM\STM3210C-EVAL_USBD-FS\Obj\stm32f10x_gpio.o
#
###############################################################################

E:\DYH\01_EmbeddedSoftware\Github\0.1_OBC\Reference\en.stm32_f105-07_f2_f4_usb-host-device_lib\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_gpio.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_gpio.c
      4            * @author  MCD Application Team
      5            * @version V3.6.1
      6            * @date    05-March-2012
      7            * @brief   This file provides all the GPIO firmware functions.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            * <h2><center>&copy; COPYRIGHT 2012 STMicroelectronics</center></h2>
     12            *
     13            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     14            * You may not use this file except in compliance with the License.
     15            * You may obtain a copy of the License at:
     16            *
     17            *        http://www.st.com/software_license_agreement_liberty_v2
     18            *
     19            * Unless required by applicable law or agreed to in writing, software 
     20            * distributed under the License is distributed on an "AS IS" BASIS, 
     21            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     22            * See the License for the specific language governing permissions and
     23            * limitations under the License.
     24            *
     25            ******************************************************************************
     26            */
     27          
     28          /* Includes ------------------------------------------------------------------*/
     29          #include "stm32f10x_gpio.h"
     30          #include "stm32f10x_rcc.h"
     31          
     32          /** @addtogroup STM32F10x_StdPeriph_Driver
     33            * @{
     34            */
     35          
     36          /** @defgroup GPIO 
     37            * @brief GPIO driver modules
     38            * @{
     39            */ 
     40          
     41          /** @defgroup GPIO_Private_TypesDefinitions
     42            * @{
     43            */
     44          
     45          /**
     46            * @}
     47            */
     48          
     49          /** @defgroup GPIO_Private_Defines
     50            * @{
     51            */
     52          
     53          /* ------------ RCC registers bit address in the alias region ----------------*/
     54          #define AFIO_OFFSET                 (AFIO_BASE - PERIPH_BASE)
     55          
     56          /* --- EVENTCR Register -----*/
     57          
     58          /* Alias word address of EVOE bit */
     59          #define EVCR_OFFSET                 (AFIO_OFFSET + 0x00)
     60          #define EVOE_BitNumber              ((uint8_t)0x07)
     61          #define EVCR_EVOE_BB                (PERIPH_BB_BASE + (EVCR_OFFSET * 32) + (EVOE_BitNumber * 4))
     62          
     63          
     64          /* ---  MAPR Register ---*/ 
     65          /* Alias word address of MII_RMII_SEL bit */ 
     66          #define MAPR_OFFSET                 (AFIO_OFFSET + 0x04) 
     67          #define MII_RMII_SEL_BitNumber      ((u8)0x17) 
     68          #define MAPR_MII_RMII_SEL_BB        (PERIPH_BB_BASE + (MAPR_OFFSET * 32) + (MII_RMII_SEL_BitNumber * 4))
     69          
     70          
     71          #define EVCR_PORTPINCONFIG_MASK     ((uint16_t)0xFF80)
     72          #define LSB_MASK                    ((uint16_t)0xFFFF)
     73          #define DBGAFR_POSITION_MASK        ((uint32_t)0x000F0000)
     74          #define DBGAFR_SWJCFG_MASK          ((uint32_t)0xF0FFFFFF)
     75          #define DBGAFR_LOCATION_MASK        ((uint32_t)0x00200000)
     76          #define DBGAFR_NUMBITS_MASK         ((uint32_t)0x00100000)
     77          /**
     78            * @}
     79            */
     80          
     81          /** @defgroup GPIO_Private_Macros
     82            * @{
     83            */
     84          
     85          /**
     86            * @}
     87            */
     88          
     89          /** @defgroup GPIO_Private_Variables
     90            * @{
     91            */
     92          
     93          /**
     94            * @}
     95            */
     96          
     97          /** @defgroup GPIO_Private_FunctionPrototypes
     98            * @{
     99            */
    100          
    101          /**
    102            * @}
    103            */
    104          
    105          /** @defgroup GPIO_Private_Functions
    106            * @{
    107            */
    108          
    109          /**
    110            * @brief  Deinitializes the GPIOx peripheral registers to their default reset values.
    111            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    112            * @retval None
    113            */
    114          void GPIO_DeInit(GPIO_TypeDef* GPIOx)
    115          {
    116            /* Check the parameters */
    117            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    118            
    119            if (GPIOx == GPIOA)
    120            {
    121              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, ENABLE);
    122              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOA, DISABLE);
    123            }
    124            else if (GPIOx == GPIOB)
    125            {
    126              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, ENABLE);
    127              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOB, DISABLE);
    128            }
    129            else if (GPIOx == GPIOC)
    130            {
    131              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, ENABLE);
    132              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOC, DISABLE);
    133            }
    134            else if (GPIOx == GPIOD)
    135            {
    136              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, ENABLE);
    137              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOD, DISABLE);
    138            }    
    139            else if (GPIOx == GPIOE)
    140            {
    141              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, ENABLE);
    142              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOE, DISABLE);
    143            } 
    144            else if (GPIOx == GPIOF)
    145            {
    146              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, ENABLE);
    147              RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOF, DISABLE);
    148            }
    149            else
    150            {
    151              if (GPIOx == GPIOG)
    152              {
    153                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, ENABLE);
    154                RCC_APB2PeriphResetCmd(RCC_APB2Periph_GPIOG, DISABLE);
    155              }
    156            }
    157          }
    158          
    159          /**
    160            * @brief  Deinitializes the Alternate Functions (remap, event control
    161            *   and EXTI configuration) registers to their default reset values.
    162            * @param  None
    163            * @retval None
    164            */
    165          void GPIO_AFIODeInit(void)
    166          {
    167            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, ENABLE);
    168            RCC_APB2PeriphResetCmd(RCC_APB2Periph_AFIO, DISABLE);
    169          }
    170          
    171          /**
    172            * @brief  Initializes the GPIOx peripheral according to the specified
    173            *         parameters in the GPIO_InitStruct.
    174            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    175            * @param  GPIO_InitStruct: pointer to a GPIO_InitTypeDef structure that
    176            *         contains the configuration information for the specified GPIO peripheral.
    177            * @retval None
    178            */
    179          void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct)
    180          {
    181            uint32_t currentmode = 0x00, currentpin = 0x00, pinpos = 0x00, pos = 0x00;
    182            uint32_t tmpreg = 0x00, pinmask = 0x00;
    183            /* Check the parameters */
    184            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    185            assert_param(IS_GPIO_MODE(GPIO_InitStruct->GPIO_Mode));
    186            assert_param(IS_GPIO_PIN(GPIO_InitStruct->GPIO_Pin));  
    187            
    188          /*---------------------------- GPIO Mode Configuration -----------------------*/
    189            currentmode = ((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x0F);
    190            if ((((uint32_t)GPIO_InitStruct->GPIO_Mode) & ((uint32_t)0x10)) != 0x00)
    191            { 
    192              /* Check the parameters */
    193              assert_param(IS_GPIO_SPEED(GPIO_InitStruct->GPIO_Speed));
    194              /* Output mode */
    195              currentmode |= (uint32_t)GPIO_InitStruct->GPIO_Speed;
    196            }
    197          /*---------------------------- GPIO CRL Configuration ------------------------*/
    198            /* Configure the eight low port pins */
    199            if (((uint32_t)GPIO_InitStruct->GPIO_Pin & ((uint32_t)0x00FF)) != 0x00)
    200            {
    201              tmpreg = GPIOx->CRL;
    202              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    203              {
    204                pos = ((uint32_t)0x01) << pinpos;
    205                /* Get the port pins position */
    206                currentpin = (GPIO_InitStruct->GPIO_Pin) & pos;
    207                if (currentpin == pos)
    208                {
    209                  pos = pinpos << 2;
    210                  /* Clear the corresponding low control register bits */
    211                  pinmask = ((uint32_t)0x0F) << pos;
    212                  tmpreg &= ~pinmask;
    213                  /* Write the mode configuration in the corresponding bits */
    214                  tmpreg |= (currentmode << pos);
    215                  /* Reset the corresponding ODR bit */
    216                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    217                  {
    218                    GPIOx->BRR = (((uint32_t)0x01) << pinpos);
    219                  }
    220                  else
    221                  {
    222                    /* Set the corresponding ODR bit */
    223                    if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    224                    {
    225                      GPIOx->BSRR = (((uint32_t)0x01) << pinpos);
    226                    }
    227                  }
    228                }
    229              }
    230              GPIOx->CRL = tmpreg;
    231            }
    232          /*---------------------------- GPIO CRH Configuration ------------------------*/
    233            /* Configure the eight high port pins */
    234            if (GPIO_InitStruct->GPIO_Pin > 0x00FF)
    235            {
    236              tmpreg = GPIOx->CRH;
    237              for (pinpos = 0x00; pinpos < 0x08; pinpos++)
    238              {
    239                pos = (((uint32_t)0x01) << (pinpos + 0x08));
    240                /* Get the port pins position */
    241                currentpin = ((GPIO_InitStruct->GPIO_Pin) & pos);
    242                if (currentpin == pos)
    243                {
    244                  pos = pinpos << 2;
    245                  /* Clear the corresponding high control register bits */
    246                  pinmask = ((uint32_t)0x0F) << pos;
    247                  tmpreg &= ~pinmask;
    248                  /* Write the mode configuration in the corresponding bits */
    249                  tmpreg |= (currentmode << pos);
    250                  /* Reset the corresponding ODR bit */
    251                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPD)
    252                  {
    253                    GPIOx->BRR = (((uint32_t)0x01) << (pinpos + 0x08));
    254                  }
    255                  /* Set the corresponding ODR bit */
    256                  if (GPIO_InitStruct->GPIO_Mode == GPIO_Mode_IPU)
    257                  {
    258                    GPIOx->BSRR = (((uint32_t)0x01) << (pinpos + 0x08));
    259                  }
    260                }
    261              }
    262              GPIOx->CRH = tmpreg;
    263            }
    264          }
    265          
    266          /**
    267            * @brief  Fills each GPIO_InitStruct member with its default value.
    268            * @param  GPIO_InitStruct : pointer to a GPIO_InitTypeDef structure which will
    269            *         be initialized.
    270            * @retval None
    271            */
    272          void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct)
    273          {
    274            /* Reset GPIO init structure parameters values */
    275            GPIO_InitStruct->GPIO_Pin  = GPIO_Pin_All;
    276            GPIO_InitStruct->GPIO_Speed = GPIO_Speed_2MHz;
    277            GPIO_InitStruct->GPIO_Mode = GPIO_Mode_IN_FLOATING;
    278          }
    279          
    280          /**
    281            * @brief  Reads the specified input port pin.
    282            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    283            * @param  GPIO_Pin:  specifies the port bit to read.
    284            *   This parameter can be GPIO_Pin_x where x can be (0..15).
    285            * @retval The input port pin value.
    286            */
    287          uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    288          {
    289            uint8_t bitstatus = 0x00;
    290            
    291            /* Check the parameters */
    292            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    293            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    294            
    295            if ((GPIOx->IDR & GPIO_Pin) != (uint32_t)Bit_RESET)
    296            {
    297              bitstatus = (uint8_t)Bit_SET;
    298            }
    299            else
    300            {
    301              bitstatus = (uint8_t)Bit_RESET;
    302            }
    303            return bitstatus;
    304          }
    305          
    306          /**
    307            * @brief  Reads the specified GPIO input data port.
    308            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    309            * @retval GPIO input data port value.
    310            */
    311          uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx)
    312          {
    313            /* Check the parameters */
    314            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    315            
    316            return ((uint16_t)GPIOx->IDR);
    317          }
    318          
    319          /**
    320            * @brief  Reads the specified output data port bit.
    321            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    322            * @param  GPIO_Pin:  specifies the port bit to read.
    323            *   This parameter can be GPIO_Pin_x where x can be (0..15).
    324            * @retval The output port pin value.
    325            */
    326          uint8_t GPIO_ReadOutputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    327          {
    328            uint8_t bitstatus = 0x00;
    329            /* Check the parameters */
    330            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    331            assert_param(IS_GET_GPIO_PIN(GPIO_Pin)); 
    332            
    333            if ((GPIOx->ODR & GPIO_Pin) != (uint32_t)Bit_RESET)
    334            {
    335              bitstatus = (uint8_t)Bit_SET;
    336            }
    337            else
    338            {
    339              bitstatus = (uint8_t)Bit_RESET;
    340            }
    341            return bitstatus;
    342          }
    343          
    344          /**
    345            * @brief  Reads the specified GPIO output data port.
    346            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    347            * @retval GPIO output data port value.
    348            */
    349          uint16_t GPIO_ReadOutputData(GPIO_TypeDef* GPIOx)
    350          {
    351            /* Check the parameters */
    352            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    353              
    354            return ((uint16_t)GPIOx->ODR);
    355          }
    356          
    357          /**
    358            * @brief  Sets the selected data port bits.
    359            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    360            * @param  GPIO_Pin: specifies the port bits to be written.
    361            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    362            * @retval None
    363            */
    364          void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    365          {
    366            /* Check the parameters */
    367            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    368            assert_param(IS_GPIO_PIN(GPIO_Pin));
    369            
    370            GPIOx->BSRR = GPIO_Pin;
    371          }
    372          
    373          /**
    374            * @brief  Clears the selected data port bits.
    375            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    376            * @param  GPIO_Pin: specifies the port bits to be written.
    377            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    378            * @retval None
    379            */
    380          void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    381          {
    382            /* Check the parameters */
    383            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    384            assert_param(IS_GPIO_PIN(GPIO_Pin));
    385            
    386            GPIOx->BRR = GPIO_Pin;
    387          }
    388          
    389          /**
    390            * @brief  Sets or clears the selected data port bit.
    391            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    392            * @param  GPIO_Pin: specifies the port bit to be written.
    393            *   This parameter can be one of GPIO_Pin_x where x can be (0..15).
    394            * @param  BitVal: specifies the value to be written to the selected bit.
    395            *   This parameter can be one of the BitAction enum values:
    396            *     @arg Bit_RESET: to clear the port pin
    397            *     @arg Bit_SET: to set the port pin
    398            * @retval None
    399            */
    400          void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)
    401          {
    402            /* Check the parameters */
    403            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    404            assert_param(IS_GET_GPIO_PIN(GPIO_Pin));
    405            assert_param(IS_GPIO_BIT_ACTION(BitVal)); 
    406            
    407            if (BitVal != Bit_RESET)
    408            {
    409              GPIOx->BSRR = GPIO_Pin;
    410            }
    411            else
    412            {
    413              GPIOx->BRR = GPIO_Pin;
    414            }
    415          }
    416          
    417          /**
    418            * @brief  Writes data to the specified GPIO data port.
    419            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    420            * @param  PortVal: specifies the value to be written to the port output data register.
    421            * @retval None
    422            */
    423          void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal)
    424          {
    425            /* Check the parameters */
    426            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    427            
    428            GPIOx->ODR = PortVal;
    429          }
    430          
    431          /**
    432            * @brief  Locks GPIO Pins configuration registers.
    433            * @param  GPIOx: where x can be (A..G) to select the GPIO peripheral.
    434            * @param  GPIO_Pin: specifies the port bit to be written.
    435            *   This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
    436            * @retval None
    437            */
    438          void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
    439          {
    440            uint32_t tmp = 0x00010000;
    441            
    442            /* Check the parameters */
    443            assert_param(IS_GPIO_ALL_PERIPH(GPIOx));
    444            assert_param(IS_GPIO_PIN(GPIO_Pin));
    445            
    446            tmp |= GPIO_Pin;
    447            /* Set LCKK bit */
    448            GPIOx->LCKR = tmp;
    449            /* Reset LCKK bit */
    450            GPIOx->LCKR =  GPIO_Pin;
    451            /* Set LCKK bit */
    452            GPIOx->LCKR = tmp;
    453            /* Read LCKK bit*/
    454            tmp = GPIOx->LCKR;
    455            /* Read LCKK bit*/
    456            tmp = GPIOx->LCKR;
    457          }
    458          
    459          /**
    460            * @brief  Selects the GPIO pin used as Event output.
    461            * @param  GPIO_PortSource: selects the GPIO port to be used as source
    462            *   for Event output.
    463            *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..E).
    464            * @param  GPIO_PinSource: specifies the pin for the Event output.
    465            *   This parameter can be GPIO_PinSourcex where x can be (0..15).
    466            * @retval None
    467            */
    468          void GPIO_EventOutputConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
    469          {
    470            uint32_t tmpreg = 0x00;
    471            /* Check the parameters */
    472            assert_param(IS_GPIO_EVENTOUT_PORT_SOURCE(GPIO_PortSource));
    473            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    474              
    475            tmpreg = AFIO->EVCR;
    476            /* Clear the PORT[6:4] and PIN[3:0] bits */
    477            tmpreg &= EVCR_PORTPINCONFIG_MASK;
    478            tmpreg |= (uint32_t)GPIO_PortSource << 0x04;
    479            tmpreg |= GPIO_PinSource;
    480            AFIO->EVCR = tmpreg;
    481          }
    482          
    483          /**
    484            * @brief  Enables or disables the Event Output.
    485            * @param  NewState: new state of the Event output.
    486            *   This parameter can be: ENABLE or DISABLE.
    487            * @retval None
    488            */
    489          void GPIO_EventOutputCmd(FunctionalState NewState)
    490          {
    491            /* Check the parameters */
    492            assert_param(IS_FUNCTIONAL_STATE(NewState));
    493            
    494            *(__IO uint32_t *) EVCR_EVOE_BB = (uint32_t)NewState;
    495          }
    496          
    497          /**
    498            * @brief  Changes the mapping of the specified pin.
    499            * @param  GPIO_Remap: selects the pin to remap.
    500            *   This parameter can be one of the following values:
    501            *     @arg GPIO_Remap_SPI1             : SPI1 Alternate Function mapping
    502            *     @arg GPIO_Remap_I2C1             : I2C1 Alternate Function mapping
    503            *     @arg GPIO_Remap_USART1           : USART1 Alternate Function mapping
    504            *     @arg GPIO_Remap_USART2           : USART2 Alternate Function mapping
    505            *     @arg GPIO_PartialRemap_USART3    : USART3 Partial Alternate Function mapping
    506            *     @arg GPIO_FullRemap_USART3       : USART3 Full Alternate Function mapping
    507            *     @arg GPIO_PartialRemap_TIM1      : TIM1 Partial Alternate Function mapping
    508            *     @arg GPIO_FullRemap_TIM1         : TIM1 Full Alternate Function mapping
    509            *     @arg GPIO_PartialRemap1_TIM2     : TIM2 Partial1 Alternate Function mapping
    510            *     @arg GPIO_PartialRemap2_TIM2     : TIM2 Partial2 Alternate Function mapping
    511            *     @arg GPIO_FullRemap_TIM2         : TIM2 Full Alternate Function mapping
    512            *     @arg GPIO_PartialRemap_TIM3      : TIM3 Partial Alternate Function mapping
    513            *     @arg GPIO_FullRemap_TIM3         : TIM3 Full Alternate Function mapping
    514            *     @arg GPIO_Remap_TIM4             : TIM4 Alternate Function mapping
    515            *     @arg GPIO_Remap1_CAN1            : CAN1 Alternate Function mapping
    516            *     @arg GPIO_Remap2_CAN1            : CAN1 Alternate Function mapping
    517            *     @arg GPIO_Remap_PD01             : PD01 Alternate Function mapping
    518            *     @arg GPIO_Remap_TIM5CH4_LSI      : LSI connected to TIM5 Channel4 input capture for calibration
    519            *     @arg GPIO_Remap_ADC1_ETRGINJ     : ADC1 External Trigger Injected Conversion remapping
    520            *     @arg GPIO_Remap_ADC1_ETRGREG     : ADC1 External Trigger Regular Conversion remapping
    521            *     @arg GPIO_Remap_ADC2_ETRGINJ     : ADC2 External Trigger Injected Conversion remapping
    522            *     @arg GPIO_Remap_ADC2_ETRGREG     : ADC2 External Trigger Regular Conversion remapping
    523            *     @arg GPIO_Remap_ETH              : Ethernet remapping (only for Connectivity line devices)
    524            *     @arg GPIO_Remap_CAN2             : CAN2 remapping (only for Connectivity line devices)
    525            *     @arg GPIO_Remap_SWJ_NoJTRST      : Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST
    526            *     @arg GPIO_Remap_SWJ_JTAGDisable  : JTAG-DP Disabled and SW-DP Enabled
    527            *     @arg GPIO_Remap_SWJ_Disable      : Full SWJ Disabled (JTAG-DP + SW-DP)
    528            *     @arg GPIO_Remap_SPI3             : SPI3/I2S3 Alternate Function mapping (only for Connectivity line devices)
    529            *                                        When the SPI3/I2S3 is remapped using this function, the SWJ is configured
    530            *                                        to Full SWJ Enabled (JTAG-DP + SW-DP) but without JTRST.   
    531            *     @arg GPIO_Remap_TIM2ITR1_PTP_SOF : Ethernet PTP output or USB OTG SOF (Start of Frame) connected
    532            *                                        to TIM2 Internal Trigger 1 for calibration (only for Connectivity line devices)
    533            *                                        If the GPIO_Remap_TIM2ITR1_PTP_SOF is enabled the TIM2 ITR1 is connected to 
    534            *                                        Ethernet PTP output. When Reset TIM2 ITR1 is connected to USB OTG SOF output.    
    535            *     @arg GPIO_Remap_PTP_PPS          : Ethernet MAC PPS_PTS output on PB05 (only for Connectivity line devices)
    536            *     @arg GPIO_Remap_TIM15            : TIM15 Alternate Function mapping (only for Value line devices)
    537            *     @arg GPIO_Remap_TIM16            : TIM16 Alternate Function mapping (only for Value line devices)
    538            *     @arg GPIO_Remap_TIM17            : TIM17 Alternate Function mapping (only for Value line devices)
    539            *     @arg GPIO_Remap_CEC              : CEC Alternate Function mapping (only for Value line devices)
    540            *     @arg GPIO_Remap_TIM1_DMA         : TIM1 DMA requests mapping (only for Value line devices)
    541            *     @arg GPIO_Remap_TIM9             : TIM9 Alternate Function mapping (only for XL-density devices)
    542            *     @arg GPIO_Remap_TIM10            : TIM10 Alternate Function mapping (only for XL-density devices)
    543            *     @arg GPIO_Remap_TIM11            : TIM11 Alternate Function mapping (only for XL-density devices)
    544            *     @arg GPIO_Remap_TIM13            : TIM13 Alternate Function mapping (only for High density Value line and XL-density devices)
    545            *     @arg GPIO_Remap_TIM14            : TIM14 Alternate Function mapping (only for High density Value line and XL-density devices)
    546            *     @arg GPIO_Remap_FSMC_NADV        : FSMC_NADV Alternate Function mapping (only for High density Value line and XL-density devices)
    547            *     @arg GPIO_Remap_TIM67_DAC_DMA    : TIM6/TIM7 and DAC DMA requests remapping (only for High density Value line devices)
    548            *     @arg GPIO_Remap_TIM12            : TIM12 Alternate Function mapping (only for High density Value line devices)
    549            *     @arg GPIO_Remap_MISC             : Miscellaneous Remap (DMA2 Channel5 Position and DAC Trigger remapping, 
    550            *                                        only for High density Value line devices)     
    551            * @param  NewState: new state of the port pin remapping.
    552            *   This parameter can be: ENABLE or DISABLE.
    553            * @retval None
    554            */
    555          void GPIO_PinRemapConfig(uint32_t GPIO_Remap, FunctionalState NewState)
    556          {
    557            uint32_t tmp = 0x00, tmp1 = 0x00, tmpreg = 0x00, tmpmask = 0x00;
    558          
    559            /* Check the parameters */
    560            assert_param(IS_GPIO_REMAP(GPIO_Remap));
    561            assert_param(IS_FUNCTIONAL_STATE(NewState));  
    562            
    563            if((GPIO_Remap & 0x80000000) == 0x80000000)
    564            {
    565              tmpreg = AFIO->MAPR2;
    566            }
    567            else
    568            {
    569              tmpreg = AFIO->MAPR;
    570            }
    571          
    572            tmpmask = (GPIO_Remap & DBGAFR_POSITION_MASK) >> 0x10;
    573            tmp = GPIO_Remap & LSB_MASK;
    574          
    575            if ((GPIO_Remap & (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK)) == (DBGAFR_LOCATION_MASK | DBGAFR_NUMBITS_MASK))
    576            {
    577              tmpreg &= DBGAFR_SWJCFG_MASK;
    578              AFIO->MAPR &= DBGAFR_SWJCFG_MASK;
    579            }
    580            else if ((GPIO_Remap & DBGAFR_NUMBITS_MASK) == DBGAFR_NUMBITS_MASK)
    581            {
    582              tmp1 = ((uint32_t)0x03) << tmpmask;
    583              tmpreg &= ~tmp1;
    584              tmpreg |= ~DBGAFR_SWJCFG_MASK;
    585            }
    586            else
    587            {
    588              tmpreg &= ~(tmp << ((GPIO_Remap >> 0x15)*0x10));
    589              tmpreg |= ~DBGAFR_SWJCFG_MASK;
    590            }
    591          
    592            if (NewState != DISABLE)
    593            {
    594              tmpreg |= (tmp << ((GPIO_Remap >> 0x15)*0x10));
    595            }
    596          
    597            if((GPIO_Remap & 0x80000000) == 0x80000000)
    598            {
    599              AFIO->MAPR2 = tmpreg;
    600            }
    601            else
    602            {
    603              AFIO->MAPR = tmpreg;
    604            }  
    605          }
    606          
    607          /**
    608            * @brief  Selects the GPIO pin used as EXTI Line.
    609            * @param  GPIO_PortSource: selects the GPIO port to be used as source for EXTI lines.
    610            *   This parameter can be GPIO_PortSourceGPIOx where x can be (A..G).
    611            * @param  GPIO_PinSource: specifies the EXTI line to be configured.
    612            *   This parameter can be GPIO_PinSourcex where x can be (0..15).
    613            * @retval None
    614            */
    615          void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource)
    616          {
    617            uint32_t tmp = 0x00;
    618            /* Check the parameters */
    619            assert_param(IS_GPIO_EXTI_PORT_SOURCE(GPIO_PortSource));
    620            assert_param(IS_GPIO_PIN_SOURCE(GPIO_PinSource));
    621            
    622            tmp = ((uint32_t)0x0F) << (0x04 * (GPIO_PinSource & (uint8_t)0x03));
    623            AFIO->EXTICR[GPIO_PinSource >> 0x02] &= ~tmp;
    624            AFIO->EXTICR[GPIO_PinSource >> 0x02] |= (((uint32_t)GPIO_PortSource) << (0x04 * (GPIO_PinSource & (uint8_t)0x03)));
    625          }
    626          
    627          /**
    628            * @brief  Selects the Ethernet media interface.
    629            * @note   This function applies only to STM32 Connectivity line devices.  
    630            * @param  GPIO_ETH_MediaInterface: specifies the Media Interface mode.
    631            *   This parameter can be one of the following values:
    632            *     @arg GPIO_ETH_MediaInterface_MII: MII mode
    633            *     @arg GPIO_ETH_MediaInterface_RMII: RMII mode    
    634            * @retval None
    635            */
    636          void GPIO_ETH_MediaInterfaceConfig(uint32_t GPIO_ETH_MediaInterface) 
    637          { 
    638            assert_param(IS_GPIO_ETH_MEDIA_INTERFACE(GPIO_ETH_MediaInterface)); 
    639          
    640            /* Configure MII_RMII selection bit */ 
    641            *(__IO uint32_t *) MAPR_MII_RMII_SEL_BB = GPIO_ETH_MediaInterface; 
    642          }
    643            
    644          /**
    645            * @}
    646            */
    647          
    648          /**
    649            * @}
    650            */
    651          
    652          /**
    653            * @}
    654            */
    655          
    656          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   GPIO_AFIODeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       8   GPIO_DeInit
         0   -> RCC_APB2PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   GPIO_ETH_MediaInterfaceConfig
      12   GPIO_EXTILineConfig
       0   GPIO_EventOutputCmd
       8   GPIO_EventOutputConfig
      24   GPIO_Init
       0   GPIO_PinLockConfig
      16   GPIO_PinRemapConfig
       0   GPIO_ReadInputData
       0   GPIO_ReadInputDataBit
       0   GPIO_ReadOutputData
       0   GPIO_ReadOutputDataBit
       0   GPIO_ResetBits
       0   GPIO_SetBits
       0   GPIO_StructInit
       0   GPIO_Write
       0   GPIO_WriteBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      22  GPIO_AFIODeInit
     154  GPIO_DeInit
       6  GPIO_ETH_MediaInterfaceConfig
      34  GPIO_EXTILineConfig
       6  GPIO_EventOutputCmd
      22  GPIO_EventOutputConfig
     182  GPIO_Init
      16  GPIO_PinLockConfig
      82  GPIO_PinRemapConfig
       6  GPIO_ReadInputData
      14  GPIO_ReadInputDataBit
       6  GPIO_ReadOutputData
      14  GPIO_ReadOutputDataBit
       4  GPIO_ResetBits
       4  GPIO_SetBits
      16  GPIO_StructInit
       4  GPIO_Write
      10  GPIO_WriteBit

 
 650 bytes in section .text
 
 650 bytes of CODE memory

Errors: none
Warnings: none
